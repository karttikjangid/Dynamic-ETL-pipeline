"""Genson-based schema generation for Tier-B pipeline."""

from typing import Any, Dict, List

from genson import SchemaBuilder

from utils.logger import get_logger

logger = get_logger(__name__)


def generate_genson_schema(records: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Generate JSON Schema using Genson from a list of records.
    
    Args:
        records: List of dictionary records to analyze
        
    Returns:
        JSON Schema dict generated by Genson
    """
    if not records:
        return {"type": "object", "properties": {}}
    
    builder = SchemaBuilder()
    builder.add_schema({"type": "object"})
    
    for record in records:
        try:
            builder.add_object(record)
        except Exception as e:
            logger.warning(f"Failed to add record to Genson schema: {e}")
            continue
    
    schema = builder.to_schema()
    logger.debug(f"Generated Genson schema with {len(schema.get('properties', {}))} properties")
    
    return schema


def extract_fields_from_genson_schema(
    genson_schema: Dict[str, Any],
    path_prefix: str = ""
) -> List[Dict[str, Any]]:
    """Extract flat field definitions from a Genson JSON Schema.
    
    Args:
        genson_schema: JSON Schema dict from Genson
        path_prefix: Prefix for nested paths
        
    Returns:
        List of field definition dicts
    """
    fields = []
    
    properties = genson_schema.get("properties", {})
    required_fields = set(genson_schema.get("required", []))
    
    for field_name, field_schema in properties.items():
        field_path = f"{path_prefix}.{field_name}" if path_prefix else field_name
        
        # Extract field type
        field_type = field_schema.get("type", "unknown")
        
        # Handle multiple types (e.g., ["string", "null"])
        if isinstance(field_type, list):
            # Filter out null and take the first non-null type
            non_null_types = [t for t in field_type if t != "null"]
            field_type = non_null_types[0] if non_null_types else "string"
            nullable = "null" in field_type
        else:
            nullable = field_name not in required_fields
        
        # Recursively process nested objects
        if field_type == "object" and "properties" in field_schema:
            nested_fields = extract_fields_from_genson_schema(
                field_schema,
                path_prefix=field_path
            )
            fields.extend(nested_fields)
        else:
            fields.append({
                "name": field_name,
                "path": field_path,
                "type": field_type,
                "nullable": nullable,
                "example_value": field_schema.get("examples", [None])[0] if "examples" in field_schema else None
            })
    
    return fields


def compute_schema_signature(genson_schema: Dict[str, Any]) -> str:
    """Compute a deterministic signature from a Genson schema.
    
    Used for detecting schema changes. Two schemas with the same signature
    are considered equivalent.
    
    Args:
        genson_schema: JSON Schema dict from Genson
        
    Returns:
        Signature string
    """
    import hashlib
    import json
    
    # Create a canonical representation (sorted keys, no whitespace)
    # Only include structural elements (type, properties, required)
    canonical = _get_canonical_schema(genson_schema)
    canonical_str = json.dumps(canonical, sort_keys=True, separators=(',', ':'))
    
    # Hash it
    signature = hashlib.sha256(canonical_str.encode()).hexdigest()[:16]
    
    return signature


def _get_canonical_schema(schema: Dict[str, Any]) -> Dict[str, Any]:
    """Get canonical representation of schema (structure only).
    
    Args:
        schema: JSON Schema dict
        
    Returns:
        Canonical schema dict with only structural elements
    """
    canonical = {}
    
    # Include type
    if "type" in schema:
        schema_type = schema["type"]
        if isinstance(schema_type, list):
            schema_type = sorted(schema_type)
        canonical["type"] = schema_type
    
    # Include required fields
    if "required" in schema:
        canonical["required"] = sorted(schema["required"])
    
    # Recursively process properties
    if "properties" in schema:
        canonical["properties"] = {}
        for prop_name, prop_schema in sorted(schema["properties"].items()):
            canonical["properties"][prop_name] = _get_canonical_schema(prop_schema)
    
    # Handle arrays
    if "items" in schema:
        canonical["items"] = _get_canonical_schema(schema["items"])
    
    return canonical
